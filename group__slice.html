<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libkirke: Slice</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libkirke
   </div>
   <div id="projectbrief">Generic functionality for building C applications.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__slice.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Slice</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlice.html">Slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3ed762baf4d14e341609a5e392c3332c"><td class="memItemLeft" align="right" valign="top"><a id="ga3ed762baf4d14e341609a5e392c3332c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>slice__default</b>&#160;&#160;&#160;(<a class="el" href="structSlice.html">Slice</a>) { 0 }</td></tr>
<tr class="separator:ga3ed762baf4d14e341609a5e392c3332c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebf28cefce13ca6ed1144058972028f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#gadebf28cefce13ca6ed1144058972028f">slice__init</a>(DATA,  LENGTH,  ELEMENT_SIZE)&#160;&#160;&#160;(<a class="el" href="structSlice.html">Slice</a>) { .data = (void*) (DATA), .length = (LENGTH), .capacity = LENGTH, .element_size = (ELEMENT_SIZE) }</td></tr>
<tr class="memdesc:gadebf28cefce13ca6ed1144058972028f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully initialize a slice with an array of known length.  <a href="group__slice.html#gadebf28cefce13ca6ed1144058972028f">More...</a><br /></td></tr>
<tr class="separator:gadebf28cefce13ca6ed1144058972028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad140dc32da9d1ef1fa62c7c165f2e46f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#gad140dc32da9d1ef1fa62c7c165f2e46f">slice__from_array</a>(ARRAY)&#160;&#160;&#160;(<a class="el" href="structSlice.html">Slice</a>) { .data = (void*) (ARRAY), .length = <a class="el" href="group__macros.html#ga92f2ca48072dedf5528253dab5139d94">ELEMENT_COUNT</a>( (ARRAY) ), .capacity = <a class="el" href="group__macros.html#ga92f2ca48072dedf5528253dab5139d94">ELEMENT_COUNT</a>( (ARRAY) ), .element_size = sizeof( (ARRAY)[ 0 ] ) }</td></tr>
<tr class="memdesc:gad140dc32da9d1ef1fa62c7c165f2e46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a slice from a stack-allocated array.  <a href="group__slice.html#gad140dc32da9d1ef1fa62c7c165f2e46f">More...</a><br /></td></tr>
<tr class="separator:gad140dc32da9d1ef1fa62c7c165f2e46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0af5810dc747fd8b21e536fab9ab33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga1d0af5810dc747fd8b21e536fab9ab33">slice__string_literal</a>(STRING_LITERAL)&#160;&#160;&#160;(<a class="el" href="structSlice.html">Slice</a>) { .data = (void*) (STRING_LITERAL), .length = <a class="el" href="group__macros.html#ga92f2ca48072dedf5528253dab5139d94">ELEMENT_COUNT</a>( (STRING_LITERAL) ) - 1, .capacity = <a class="el" href="group__macros.html#ga92f2ca48072dedf5528253dab5139d94">ELEMENT_COUNT</a>( (STRING_LITERAL) ) - 1, .element_size = 1 }</td></tr>
<tr class="memdesc:ga1d0af5810dc747fd8b21e536fab9ab33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a slice from a string literal.  <a href="group__slice.html#ga1d0af5810dc747fd8b21e536fab9ab33">More...</a><br /></td></tr>
<tr class="separator:ga1d0af5810dc747fd8b21e536fab9ab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga641d5378df1376add1b932e8a64af0e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga641d5378df1376add1b932e8a64af0e2">slice__index</a>(SLICE_PTR,  TYPE,  INDEX)&#160;&#160;&#160;( ( (TYPE*) (SLICE_PTR)-&gt;data )[ (INDEX) ] )</td></tr>
<tr class="memdesc:ga641d5378df1376add1b932e8a64af0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the element of the <a class="el" href="structSlice.html">Slice</a> corresponding to the the specified index.  <a href="group__slice.html#ga641d5378df1376add1b932e8a64af0e2">More...</a><br /></td></tr>
<tr class="separator:ga641d5378df1376add1b932e8a64af0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fbe3f1d4df19060519793abe4eddb99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga1fbe3f1d4df19060519793abe4eddb99">slice__data</a>(SLICE_PTR,  TYPE)&#160;&#160;&#160;( (TYPE*) (SLICE_PTR)-&gt;data )</td></tr>
<tr class="memdesc:ga1fbe3f1d4df19060519793abe4eddb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the underlying data of the specified <a class="el" href="structSlice.html">Slice</a>.  <a href="group__slice.html#ga1fbe3f1d4df19060519793abe4eddb99">More...</a><br /></td></tr>
<tr class="separator:ga1fbe3f1d4df19060519793abe4eddb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8631dfab6497698b91b9f1f29634bf91"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga8631dfab6497698b91b9f1f29634bf91">FreeFunction</a>) (<a class="el" href="structAllocator.html">Allocator</a> *allocator, void *pointer)</td></tr>
<tr class="memdesc:ga8631dfab6497698b91b9f1f29634bf91"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prototype for a free function, which is intended to be passed to slice__free__full.  <a href="group__slice.html#ga8631dfab6497698b91b9f1f29634bf91">More...</a><br /></td></tr>
<tr class="separator:ga8631dfab6497698b91b9f1f29634bf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga07ac01ac941fb5d1fd50f5f90e2b46d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSlice.html">Slice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga07ac01ac941fb5d1fd50f5f90e2b46d9">slice__new</a> (<a class="el" href="structAllocator.html">Allocator</a> *allocator, unsigned long long element_size, unsigned long long element_count)</td></tr>
<tr class="memdesc:ga07ac01ac941fb5d1fd50f5f90e2b46d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structSlice.html">Slice</a> data structure on the heap, using the provided allocator.  <a href="group__slice.html#ga07ac01ac941fb5d1fd50f5f90e2b46d9">More...</a><br /></td></tr>
<tr class="separator:ga07ac01ac941fb5d1fd50f5f90e2b46d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5336c6de6fae61b7e0590a1d759068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSlice.html">Slice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#gaef5336c6de6fae61b7e0590a1d759068">slice__new__steal</a> (<a class="el" href="structAllocator.html">Allocator</a> *allocator, unsigned long long element_size, unsigned long long element_count, void *data, unsigned long long data_capacity)</td></tr>
<tr class="memdesc:gaef5336c6de6fae61b7e0590a1d759068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structSlice.html">Slice</a> data structure on the heap using the provided allocator. Assumes ownership of the supplied data.  <a href="group__slice.html#gaef5336c6de6fae61b7e0590a1d759068">More...</a><br /></td></tr>
<tr class="separator:gaef5336c6de6fae61b7e0590a1d759068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed79fa3d7ed8e5b84ebc8e718c71cb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSlice.html">Slice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#gaed79fa3d7ed8e5b84ebc8e718c71cb56">slice__copy</a> (<a class="el" href="structAllocator.html">Allocator</a> *allocator, <a class="el" href="structSlice.html">Slice</a> const *slice)</td></tr>
<tr class="memdesc:gaed79fa3d7ed8e5b84ebc8e718c71cb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new deep copy of a <a class="el" href="structSlice.html">Slice</a> structure. The new <a class="el" href="structSlice.html">Slice</a> contains its own newly-allocated memory; memory is not shared between the original and the copy.  <a href="group__slice.html#gaed79fa3d7ed8e5b84ebc8e718c71cb56">More...</a><br /></td></tr>
<tr class="separator:gaed79fa3d7ed8e5b84ebc8e718c71cb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fb55ee28346ef42a4cea80132353ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga88fb55ee28346ef42a4cea80132353ca">slice__free</a> (<a class="el" href="structAllocator.html">Allocator</a> *allocator, <a class="el" href="structSlice.html">Slice</a> *slice)</td></tr>
<tr class="memdesc:ga88fb55ee28346ef42a4cea80132353ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a dynamically-allocated <a class="el" href="structSlice.html">Slice</a> structure This method will free the data field of the structure as well. However, if the elements contained in the data field are themselves dynamically allocated, those will not be freed. In that case, use slice__free__full.  <a href="group__slice.html#ga88fb55ee28346ef42a4cea80132353ca">More...</a><br /></td></tr>
<tr class="separator:ga88fb55ee28346ef42a4cea80132353ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e871d9b9558cdb985128afa071a2eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga1e871d9b9558cdb985128afa071a2eee">slice__free__full</a> (<a class="el" href="structAllocator.html">Allocator</a> *allocator, <a class="el" href="structSlice.html">Slice</a> *slice, <a class="el" href="group__slice.html#ga8631dfab6497698b91b9f1f29634bf91">FreeFunction</a> free_function)</td></tr>
<tr class="memdesc:ga1e871d9b9558cdb985128afa071a2eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a dynamically-allocated <a class="el" href="structSlice.html">Slice</a> structure, first calling the supplied FreeFunction on each of the elements contained within the <a class="el" href="structSlice.html">Slice</a>.  <a href="group__slice.html#ga1e871d9b9558cdb985128afa071a2eee">More...</a><br /></td></tr>
<tr class="separator:ga1e871d9b9558cdb985128afa071a2eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728f2ac45ba39f2a989981f9f43f2ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga728f2ac45ba39f2a989981f9f43f2ec6">slice__clear_elements</a> (<a class="el" href="structSlice.html">Slice</a> *slice, unsigned long long start_index, unsigned long long element_count)</td></tr>
<tr class="memdesc:ga728f2ac45ba39f2a989981f9f43f2ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified elements of a <a class="el" href="structSlice.html">Slice</a> by setting them equal to 0.  <a href="group__slice.html#ga728f2ac45ba39f2a989981f9f43f2ec6">More...</a><br /></td></tr>
<tr class="separator:ga728f2ac45ba39f2a989981f9f43f2ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee1a1a545f482ad8d7bea1a04f47330"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga9ee1a1a545f482ad8d7bea1a04f47330">slice__equals</a> (<a class="el" href="structSlice.html">Slice</a> const *first, <a class="el" href="structSlice.html">Slice</a> const *second)</td></tr>
<tr class="memdesc:ga9ee1a1a545f482ad8d7bea1a04f47330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="structSlice.html">Slice</a> structures for equality.  <a href="group__slice.html#ga9ee1a1a545f482ad8d7bea1a04f47330">More...</a><br /></td></tr>
<tr class="separator:ga9ee1a1a545f482ad8d7bea1a04f47330"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0a34cdb3a48c2d71b36e6c8bdbb02a4f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga0a34cdb3a48c2d71b36e6c8bdbb02a4f">Slice::data</a></td></tr>
<tr class="separator:ga0a34cdb3a48c2d71b36e6c8bdbb02a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e786827d9d28606670077c37a126791"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga1e786827d9d28606670077c37a126791">Slice::length</a></td></tr>
<tr class="separator:ga1e786827d9d28606670077c37a126791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645bb2df2be09597f82bce0d9754f814"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga645bb2df2be09597f82bce0d9754f814">Slice::capacity</a></td></tr>
<tr class="separator:ga645bb2df2be09597f82bce0d9754f814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f70e894d1912ac46222d38d82045dc"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice.html#ga47f70e894d1912ac46222d38d82045dc">Slice::element_size</a></td></tr>
<tr class="separator:ga47f70e894d1912ac46222d38d82045dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1fbe3f1d4df19060519793abe4eddb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fbe3f1d4df19060519793abe4eddb99">&#9670;&nbsp;</a></span>slice__data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slice__data</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SLICE_PTR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;( (TYPE*) (SLICE_PTR)-&gt;data )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pointer to the underlying data of the specified <a class="el" href="structSlice.html">Slice</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SLICE_PTR</td><td>A pointer to the slice whose data is desired. </td></tr>
    <tr><td class="paramname">TYPE</td><td>The underlying type of the <a class="el" href="structSlice.html">Slice</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A typed pointer to the <a class="el" href="structSlice.html">Slice</a>'s underlying data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Be careful with <code>TYPE</code>. Ensure that it matches the type of the <a class="el" href="structSlice.html">Slice</a>'s underlying data. </dd>
<dd>
Modifying the returned data will modify the underlying <a class="el" href="structSlice.html">Slice</a>. </dd></dl>

</div>
</div>
<a id="gad140dc32da9d1ef1fa62c7c165f2e46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad140dc32da9d1ef1fa62c7c165f2e46f">&#9670;&nbsp;</a></span>slice__from_array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slice__from_array</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ARRAY</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="structSlice.html">Slice</a>) { .data = (void*) (ARRAY), .length = <a class="el" href="group__macros.html#ga92f2ca48072dedf5528253dab5139d94">ELEMENT_COUNT</a>( (ARRAY) ), .capacity = <a class="el" href="group__macros.html#ga92f2ca48072dedf5528253dab5139d94">ELEMENT_COUNT</a>( (ARRAY) ), .element_size = sizeof( (ARRAY)[ 0 ] ) }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a slice from a stack-allocated array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ARRAY</td><td>The stack-allocated array to be contained within the slice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="structSlice.html">Slice</a> object containing the specified array. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only stack-allocated arrays may be used, not pointers. The compiler must be able to determine the length of the array. </dd></dl>

</div>
</div>
<a id="ga641d5378df1376add1b932e8a64af0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga641d5378df1376add1b932e8a64af0e2">&#9670;&nbsp;</a></span>slice__index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slice__index</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SLICE_PTR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">INDEX&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;( ( (TYPE*) (SLICE_PTR)-&gt;data )[ (INDEX) ] )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the element of the <a class="el" href="structSlice.html">Slice</a> corresponding to the the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SLICE_PTR</td><td>A pointer to the slice containing the desired element. </td></tr>
    <tr><td class="paramname">TYPE</td><td>The type of the underlying element. </td></tr>
    <tr><td class="paramname">INDEX</td><td>The zero-based index at which the desired element is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element of the <a class="el" href="structSlice.html">Slice</a> corresponding to the specified index. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Be careful with <code>TYPE</code>. Ensure that it matches the type of the <a class="el" href="structSlice.html">Slice</a>'s underlying data. </dd>
<dd>
Modifying the returned value will modify the underlying <a class="el" href="structSlice.html">Slice</a>. </dd></dl>

</div>
</div>
<a id="gadebf28cefce13ca6ed1144058972028f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadebf28cefce13ca6ed1144058972028f">&#9670;&nbsp;</a></span>slice__init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slice__init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DATA, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LENGTH, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ELEMENT_SIZE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="structSlice.html">Slice</a>) { .data = (void*) (DATA), .length = (LENGTH), .capacity = LENGTH, .element_size = (ELEMENT_SIZE) }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully initialize a slice with an array of known length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DATA</td><td>A pointer to the start of the array </td></tr>
    <tr><td class="paramname">LENGTH</td><td>The length of the array in elements </td></tr>
    <tr><td class="paramname">ELEMENT_SIZE</td><td>The size, in bytes of one array element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized slice object containing the specified data. </dd></dl>

</div>
</div>
<a id="ga1d0af5810dc747fd8b21e536fab9ab33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d0af5810dc747fd8b21e536fab9ab33">&#9670;&nbsp;</a></span>slice__string_literal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slice__string_literal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">STRING_LITERAL</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="structSlice.html">Slice</a>) { .data = (void*) (STRING_LITERAL), .length = <a class="el" href="group__macros.html#ga92f2ca48072dedf5528253dab5139d94">ELEMENT_COUNT</a>( (STRING_LITERAL) ) - 1, .capacity = <a class="el" href="group__macros.html#ga92f2ca48072dedf5528253dab5139d94">ELEMENT_COUNT</a>( (STRING_LITERAL) ) - 1, .element_size = 1 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a slice from a string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STRING_LITERAL</td><td>The string literal to be contained within the slice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="structSlice.html">Slice</a> object containing the specified string </dd></dl>
<dl class="section note"><dt>Note</dt><dd>slice__string_literal may be called inline without encountering address of temporary variable error, as in: <a class="el" href="structSlice.html">Slice</a> a_string = slice__string_literal( "This is a string" ); </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8631dfab6497698b91b9f1f29634bf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8631dfab6497698b91b9f1f29634bf91">&#9670;&nbsp;</a></span>FreeFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * FreeFunction) (<a class="el" href="structAllocator.html">Allocator</a> *allocator, void *pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A prototype for a free function, which is intended to be passed to slice__free__full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>A pointer to the data to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga728f2ac45ba39f2a989981f9f43f2ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga728f2ac45ba39f2a989981f9f43f2ec6">&#9670;&nbsp;</a></span>slice__clear_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slice__clear_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice.html">Slice</a> *&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>element_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the specified elements of a <a class="el" href="structSlice.html">Slice</a> by setting them equal to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>A pointer to the <a class="el" href="structSlice.html">Slice</a> whose elements will be cleared. </td></tr>
    <tr><td class="paramname">start_index</td><td>The index of the first element to be cleared. </td></tr>
    <tr><td class="paramname">element_count</td><td>The number of elements to be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed79fa3d7ed8e5b84ebc8e718c71cb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed79fa3d7ed8e5b84ebc8e718c71cb56">&#9670;&nbsp;</a></span>slice__copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSlice.html">Slice</a>* slice__copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAllocator.html">Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice.html">Slice</a> const *&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new deep copy of a <a class="el" href="structSlice.html">Slice</a> structure. The new <a class="el" href="structSlice.html">Slice</a> contains its own newly-allocated memory; memory is not shared between the original and the copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>A pointer to the allocator to use to allocate the new <a class="el" href="structSlice.html">Slice</a>. </td></tr>
    <tr><td class="paramname">slice</td><td>The slice to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structSlice.html">Slice</a> containing the same element_size, capacity, length, and elements as the original. </dd></dl>

</div>
</div>
<a id="ga9ee1a1a545f482ad8d7bea1a04f47330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee1a1a545f482ad8d7bea1a04f47330">&#9670;&nbsp;</a></span>slice__equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char slice__equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice.html">Slice</a> const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice.html">Slice</a> const *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="structSlice.html">Slice</a> structures for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first <a class="el" href="structSlice.html">Slice</a> to be compared. </td></tr>
    <tr><td class="paramname">second</td><td>The second <a class="el" href="structSlice.html">Slice</a> to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if both <a class="el" href="structSlice.html">Slice</a> structures are equal - that is, they have the same element size, length, and if they contain the same elements. Capacity is not compared. </dd>
<dd>
0 if both <a class="el" href="structSlice.html">Slice</a> structures are not equal. </dd></dl>

</div>
</div>
<a id="ga88fb55ee28346ef42a4cea80132353ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88fb55ee28346ef42a4cea80132353ca">&#9670;&nbsp;</a></span>slice__free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slice__free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAllocator.html">Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice.html">Slice</a> *&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a dynamically-allocated <a class="el" href="structSlice.html">Slice</a> structure This method will free the data field of the structure as well. However, if the elements contained in the data field are themselves dynamically allocated, those will not be freed. In that case, use slice__free__full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>A pointer to the slice structure to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only call this on a dynamically-allocated <a class="el" href="structSlice.html">Slice</a>, such as one created with slice__new </dd></dl>

</div>
</div>
<a id="ga1e871d9b9558cdb985128afa071a2eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e871d9b9558cdb985128afa071a2eee">&#9670;&nbsp;</a></span>slice__free__full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slice__free__full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAllocator.html">Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice.html">Slice</a> *&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__slice.html#ga8631dfab6497698b91b9f1f29634bf91">FreeFunction</a>&#160;</td>
          <td class="paramname"><em>free_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a dynamically-allocated <a class="el" href="structSlice.html">Slice</a> structure, first calling the supplied FreeFunction on each of the elements contained within the <a class="el" href="structSlice.html">Slice</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>the allocator used to allocate memory for both the <a class="el" href="structSlice.html">Slice</a> and its elements. </td></tr>
    <tr><td class="paramname">free_function</td><td>The function which will be called to free each element in slice-&gt;data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the allocator used to allocate the <code>slice</code> and each element of slice-&gt;data must be the same. </dd></dl>

</div>
</div>
<a id="ga07ac01ac941fb5d1fd50f5f90e2b46d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ac01ac941fb5d1fd50f5f90e2b46d9">&#9670;&nbsp;</a></span>slice__new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSlice.html">Slice</a>* slice__new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAllocator.html">Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>element_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="structSlice.html">Slice</a> data structure on the heap, using the provided allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>A pointer to the allocator to use for dynamic memory allocation. </td></tr>
    <tr><td class="paramname">element_size</td><td>The size of the elements to be stored in the slice. </td></tr>
    <tr><td class="paramname">element_count</td><td>The maximum number of elements this slice will hold before needing to allocate more memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly-allocated slice with length 0 and storage for <code>element_count</code> elements of size <code>element_size</code>. </dd></dl>

</div>
</div>
<a id="gaef5336c6de6fae61b7e0590a1d759068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5336c6de6fae61b7e0590a1d759068">&#9670;&nbsp;</a></span>slice__new__steal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSlice.html">Slice</a>* slice__new__steal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAllocator.html">Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>element_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>data_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="structSlice.html">Slice</a> data structure on the heap using the provided allocator. Assumes ownership of the supplied data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>A pointer to the allocator to use for dynamic memory allocation. </td></tr>
    <tr><td class="paramname">element_size</td><td>The size of the elements to be stored in the slice. </td></tr>
    <tr><td class="paramname">element_count</td><td>The maximum number of elements this slice will hold before needing to allocate more memory. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the data which will be stored in the <a class="el" href="structSlice.html">Slice</a>. The <a class="el" href="structSlice.html">Slice</a> assumes ownership of this data. It retains a reference in the data field, and this memory will be freed when slice__free or slice__free__full is called. </td></tr>
    <tr><td class="paramname">data_capacity</td><td>The allocated capacity of <code>data</code>, in elements. This is distinct from <code>element_count</code>. While <code>element_count</code> refers to the number of elements actually stored within the memory pointed to by <code>data</code>, <code>data_capacity</code> refers to the number of elements which <code>data</code> is able to hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly-allocated slice containing <code>data</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga645bb2df2be09597f82bce0d9754f814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga645bb2df2be09597f82bce0d9754f814">&#9670;&nbsp;</a></span>capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long Slice::capacity</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The allocated capacity of the <a class="el" href="structSlice.html">Slice</a>, in elements. </p>

</div>
</div>
<a id="ga0a34cdb3a48c2d71b36e6c8bdbb02a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a34cdb3a48c2d71b36e6c8bdbb02a4f">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Slice::data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A generic pointer to memory referenced by the <a class="el" href="structSlice.html">Slice</a> </p>

</div>
</div>
<a id="ga47f70e894d1912ac46222d38d82045dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47f70e894d1912ac46222d38d82045dc">&#9670;&nbsp;</a></span>element_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long Slice::element_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size of a single element in the <a class="el" href="structSlice.html">Slice</a>, in bytes. </p>

</div>
</div>
<a id="ga1e786827d9d28606670077c37a126791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e786827d9d28606670077c37a126791">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long Slice::length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The length of the <a class="el" href="structSlice.html">Slice</a>, in elements </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
